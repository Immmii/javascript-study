# 04장 변수
- 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 식별자: 값이 저장되어 있는 메모리 주소를 가리킴
- 초기화: 변수가 선언된 이후 최초로 값을 할당하는 것을 의미 (garbage value가 나오지 않도록 함)

### 호이스팅
- 소스코드 평가 과정에서 모든 선언문이 먼저 실행됨
- 선언은 런타임 이전에 실행되나 할당은 런타임에 실행

### 재할당
- 재할당 시 기존의 메모리 공간을 사용하지 않고, 새로운 메모리 공간을 확보하여 값을 저장

### 가비지 콜렉터
- 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능

### 언매니지드 언어와 매니지드 언어
- 언매니지드 언어: 메모리 제어 기능 제공, 성능 확보 가능, 오류 생산 가능성 (ex. C언어)
- 매니지드 언어: 메모리 제어 허용 X, 성능 손실 감수, 생산성 확보 (ex. JavaScript)


# 05장 표현식과 문
- 값: 식이 평가되어 생성된 결과
- 리터럴: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
- 표현식: 값으로 평가될 수 있는 문
- 문: 프로그램을 구성하는 기본 단위이자 최소 실행 단위
- 토큰: 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소


# 06장 데이터 타입
### 타입
|구분|타입|
|:---:|:---:|
|원시타입|숫자|
||문자열|
||불리언|
||undefined|
||null|
||symbol|
|객체타입|객체, 함수, 배열|

### 숫자 타입
- 모든 수를 64비트 부동소수점 형식으로 처리

### null 타입
- 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거
- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 함

### 심벌 타입
- ES6에서 추가
- 다른 값과 중복 X

### 데이터 타입의 필요성
- 값을 메모리에 저장하고 참조할 때 필요
- 값 해석 시 필요

### 동적 타이핑
- 선언이 아닌 할당에 의해 타입이 결정
- 변수를 최소한으로 사용하고 스코프를 좁게 만들어야 함


# 7장 연산자
### 산술 연산자
- 산술 연산이 불가능할 경우 NaN을 반환
- \+ 연산자의 경우 피연산자 중 하나 이상이 문자열이라면 문자열 연결 연산자로 동작
- 암묵적으로 타입이 자동 변환되기도 함

### 할당 연산자
- 부수 효과 있음
- 할당문은 할당된 값으로 평가되므로 연쇄 할당이 가능

### 비교 연산자
- 동등 비교 연산자의 경우 암묵적 타입 변환을 통해 타입을 일치시킴
- ```NaN != NaN``` 이므로 NaN인지 판단할 때에는 ```Number.isNaN()``` 함수 이용
- ```if...else```문은 값처럼 사용할 수 없으나 삼항 연산자 표현식은 값으로 사용 가능

### 쉼표 연산자
- 왼쪽부터 차례대로 평가하고 마지막 피연산자의 평가가 끝나면 그 결과를 반환


# 8장 제어문
### 레이블 문
```javascript
outer: for (let i = 0; i < 3; i++) {
  break outer;
}
```
- 식별자가 붙은 문
- 중첩 for 문 탈출 시 유용하나 그 외의 경우 사용 X (가독성 하락)

# 9장 타입 변환과 단축 평가
### 타입 변환
- 명시적 타입 변환 (타입 캐스팅)
```javascript
let num = 10;
let str = num.toString();
```
- 암묵적 타입 변환
```javascript
let num = 10;
let str = num + '';
```
새로운 문자열 '10'을 생성한 후 표현식을 평가

### 문자열 타입으로 변환
- \+ 연산자, 템플릿 리터럴

### 숫자 타입으로 변환
- 산술 연산자, 비교 연산자
- '', [], null, false는 0으로, true는 1로 변환
- 객체, 빈 배열이 아닌 배열, undefined는 변환 X (NaN)

### 불리언 타입으로 변환
- 제어문 또는 삼항 연산자의 조건식
- 값을 불리언 타입이 아닌 Truthy와 Falsy로 구분
- undefined, null, 0, NaN, ''은 Falsy
- '0', {}, []은 Truthy ([]은 객체라 Truthy임)

### 단축 평가
- 표현식을 평가하는 도중 결과가 확정된 경우 나머지 평가 과정을 생략
- 논리곱(&&)과 논리합(||) 연산자는 논리 연산의 결과를 결정하는 피연산자를 타입 변환 없이 그대로 반환
- 기본값 설정 혹은 변수가 null 혹은 undefined인지 확인하고 프로퍼티 참조해야 할 때 사용

### 옵셔널 체이닝 연산자
- 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않다면 참조를 이어감
- ES11에서 도입
```javascript
let elem = null;
let value = elem?.value;
```

### null 병합 연산자
- 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환
- ES11에서 추가
```javascript
let foo = null ?? 'default';
```


# ✨토론 주제
### 자바스크립트의 메모리 관리
**메모리의 힙과 스택**
- 힙: 정적 메모리 할당당
  - 정적 데이터 저장
  - 원시 값 혹은 객체나 함수의 참조 저장
  - 고정된 크기의 메모리 할당

- 스택: 동적 메모리 할당
  - 객체 혹은 함수 저장

**가비지 콜렉터**   
메모리가 사용되지 않는 순간을 정확히 알 수 없으므로, 근사해를 제공하는 알고리즘 사용
1. Reference-counting Garbage Collection
  - 참고가 없는 개체 수집   
  - 순환 참조 문제

2. Mark-and-Sweep Algorithm
- 루트(window) 객체에서 dfs로 도달할 수 있는지 감지
- 도달할 수 없는 객체를 쓰레기로 Marking하고 나중에 Sweeping
- 순환 참조 문제 해결
- 가비지 컬렉션 도중 프로그램 실행이 잠시 중단되며 Mark-and-Sweep이 여러 번 실행되면 도달 가능한 객체가 많은 미사용 메모리들로 인해 분리된다는 단점 존재
- 모든 최신 브라우저에서 구현

**참고**   
- https://velog.io/@sejinkim/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%84%A4%EB%AA%85
- https://blog.naver.com/sssang97/221567636644